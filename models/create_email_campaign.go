// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateEmailCampaign create email campaign
// swagger:model createEmailCampaign
type CreateEmailCampaign struct {

	// Status of A/B Test. abTesting = false means it is disabled, & abTesting = true means it is enabled. 'subjectA', 'subjectB', 'splitRule', 'winnerCriteria' & 'winnerDelay' will be considered when abTesting is set to true. 'subjectA' & 'subjectB' are mandatory together & 'subject' if passed is ignored. Can be set to true only if 'sendAtBestTime' is 'false'. You will be able to set up two subject lines for your campaign and send them to a random sample of your total recipients. Half of the test group will receive version A, and the other half will receive version B
	AbTesting *bool `json:"abTesting,omitempty"`

	// Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
	AttachmentURL string `json:"attachmentUrl,omitempty"`

	// Footer of the email campaign
	Footer string `json:"footer,omitempty"`

	// Header of the email campaign
	Header string `json:"header,omitempty"`

	// Mandatory if htmlUrl and templateId are empty. Body of the message (HTML)
	HTMLContent string `json:"htmlContent,omitempty"`

	// Mandatory if htmlContent and templateId are empty. Url to the message (HTML)
	HTMLURL string `json:"htmlUrl,omitempty"`

	// Mandatory if ipWarmupEnable is set to true. Set a percentage increase rate for warming up your ip. We recommend you set the increase rate to 30% per day. If you want to send the same number of emails every day, set the daily increase value to 0%.
	// Maximum: 100
	// Minimum: 0
	IncreaseRate *int64 `json:"increaseRate,omitempty"`

	// Mandatory if ipWarmupEnable is set to true. Set an initial quota greater than 1 for warming up your ip. We recommend you set a value of 3000.
	InitialQuota int64 `json:"initialQuota,omitempty"`

	// Use true to embedded the images in your email. Final size of the email should be less than 4MB. Campaigns with embedded images can not be sent to more than 5000 contacts
	InlineImageActivation *bool `json:"inlineImageActivation,omitempty"`

	// Available for dedicated ip clients. Set this to true if you wish to warm up your ip.
	IPWarmupEnable *bool `json:"ipWarmupEnable,omitempty"`

	// Use true to enable the mirror link
	MirrorActive bool `json:"mirrorActive,omitempty"`

	// Name of the campaign
	// Required: true
	Name *string `json:"name"`

	// Pass the set of attributes to customize the type classic campaign. For example, {'FNAME':'Joe', 'LNAME':'Doe'}. Only available if 'type' is 'classic'. It's considered only if campaign is in New Template Language format. The New Template Language is dependent on the values of 'subject', 'htmlContent/htmlUrl', 'sender.name' & 'toField'
	Params interface{} `json:"params,omitempty"`

	// recipients
	Recipients *CreateEmailCampaignRecipients `json:"recipients,omitempty"`

	// Email on which the campaign recipients will be able to reply to
	// Format: email
	ReplyTo strfmt.Email `json:"replyTo,omitempty"`

	// Sending UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result. If sendAtBestTime is set to true, your campaign will be sent according to the date passed (ignoring the time part).
	// Format: date-time
	ScheduledAt strfmt.DateTime `json:"scheduledAt,omitempty"`

	// Set this to true if you want to send your campaign at best time.
	SendAtBestTime *bool `json:"sendAtBestTime,omitempty"`

	// sender
	// Required: true
	Sender *CreateEmailCampaignSender `json:"sender"`

	// Add the size of your test groups. Mandatory if abTesting = true & 'recipients' is passed. We'll send version A and B to a random sample of recipients, and then the winning version to everyone else
	// Maximum: 50
	// Minimum: 1
	SplitRule int64 `json:"splitRule,omitempty"`

	// Subject of the campaign. Mandatory if abTesting is false. Ignored if abTesting is true.
	Subject string `json:"subject,omitempty"`

	// Subject A of the campaign. Mandatory if abTesting = true. subjectA & subjectB should have unique value
	SubjectA string `json:"subjectA,omitempty"`

	// Subject B of the campaign. Mandatory if abTesting = true. subjectA & subjectB should have unique value
	SubjectB string `json:"subjectB,omitempty"`

	// Tag of the campaign
	Tag string `json:"tag,omitempty"`

	// Mandatory if htmlContent and htmlUrl are empty. Id of the transactional email template with status 'active'. Used to copy only its content fetched from htmlContent/htmlUrl to an email campaign for RSS feature.
	TemplateID int64 `json:"templateId,omitempty"`

	// To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your SendinBlue account. If input parameter 'params' used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
	ToField string `json:"toField,omitempty"`

	// Customize the utm_campaign value. If this field is empty, the campaign name will be used. Only alphanumeric characters and spaces are allowed
	UtmCampaign string `json:"utmCampaign,omitempty"`

	// Choose the metrics that will determinate the winning version. Mandatory if 'splitRule' >= 1 and < 50. If splitRule = 50, 'winnerCriteria' is ignored if passed
	// Enum: [open click]
	WinnerCriteria string `json:"winnerCriteria,omitempty"`

	// Choose the duration of the test in hours. Maximum is 7 days, pass 24*7 = 168 hours. The winning version will be sent at the end of the test. Mandatory if 'splitRule' >= 1 and < 50. If splitRule = 50, 'winnerDelay' is ignored if passed
	// Maximum: 168
	// Minimum: 1
	WinnerDelay int64 `json:"winnerDelay,omitempty"`
}

// Validate validates this create email campaign
func (m *CreateEmailCampaign) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIncreaseRate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecipients(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReplyTo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScheduledAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSender(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSplitRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWinnerCriteria(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWinnerDelay(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateEmailCampaign) validateIncreaseRate(formats strfmt.Registry) error {

	if swag.IsZero(m.IncreaseRate) { // not required
		return nil
	}

	if err := validate.MinimumInt("increaseRate", "body", int64(*m.IncreaseRate), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("increaseRate", "body", int64(*m.IncreaseRate), 100, false); err != nil {
		return err
	}

	return nil
}

func (m *CreateEmailCampaign) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *CreateEmailCampaign) validateRecipients(formats strfmt.Registry) error {

	if swag.IsZero(m.Recipients) { // not required
		return nil
	}

	if m.Recipients != nil {
		if err := m.Recipients.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipients")
			}
			return err
		}
	}

	return nil
}

func (m *CreateEmailCampaign) validateReplyTo(formats strfmt.Registry) error {

	if swag.IsZero(m.ReplyTo) { // not required
		return nil
	}

	if err := validate.FormatOf("replyTo", "body", "email", m.ReplyTo.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CreateEmailCampaign) validateScheduledAt(formats strfmt.Registry) error {

	if swag.IsZero(m.ScheduledAt) { // not required
		return nil
	}

	if err := validate.FormatOf("scheduledAt", "body", "date-time", m.ScheduledAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CreateEmailCampaign) validateSender(formats strfmt.Registry) error {

	if err := validate.Required("sender", "body", m.Sender); err != nil {
		return err
	}

	if m.Sender != nil {
		if err := m.Sender.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sender")
			}
			return err
		}
	}

	return nil
}

func (m *CreateEmailCampaign) validateSplitRule(formats strfmt.Registry) error {

	if swag.IsZero(m.SplitRule) { // not required
		return nil
	}

	if err := validate.MinimumInt("splitRule", "body", int64(m.SplitRule), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("splitRule", "body", int64(m.SplitRule), 50, false); err != nil {
		return err
	}

	return nil
}

var createEmailCampaignTypeWinnerCriteriaPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["open","click"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createEmailCampaignTypeWinnerCriteriaPropEnum = append(createEmailCampaignTypeWinnerCriteriaPropEnum, v)
	}
}

const (

	// CreateEmailCampaignWinnerCriteriaOpen captures enum value "open"
	CreateEmailCampaignWinnerCriteriaOpen string = "open"

	// CreateEmailCampaignWinnerCriteriaClick captures enum value "click"
	CreateEmailCampaignWinnerCriteriaClick string = "click"
)

// prop value enum
func (m *CreateEmailCampaign) validateWinnerCriteriaEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, createEmailCampaignTypeWinnerCriteriaPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *CreateEmailCampaign) validateWinnerCriteria(formats strfmt.Registry) error {

	if swag.IsZero(m.WinnerCriteria) { // not required
		return nil
	}

	// value enum
	if err := m.validateWinnerCriteriaEnum("winnerCriteria", "body", m.WinnerCriteria); err != nil {
		return err
	}

	return nil
}

func (m *CreateEmailCampaign) validateWinnerDelay(formats strfmt.Registry) error {

	if swag.IsZero(m.WinnerDelay) { // not required
		return nil
	}

	if err := validate.MinimumInt("winnerDelay", "body", int64(m.WinnerDelay), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("winnerDelay", "body", int64(m.WinnerDelay), 168, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CreateEmailCampaign) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreateEmailCampaign) UnmarshalBinary(b []byte) error {
	var res CreateEmailCampaign
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CreateEmailCampaignRecipients List ids to include/exclude from campaign
// swagger:model CreateEmailCampaignRecipients
type CreateEmailCampaignRecipients struct {

	// List ids to exclude from the campaign
	ExclusionListIds []int64 `json:"exclusionListIds"`

	// Mandatory if scheduledAt is not empty. List Ids to send the campaign to
	ListIds []int64 `json:"listIds"`
}

// Validate validates this create email campaign recipients
func (m *CreateEmailCampaignRecipients) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CreateEmailCampaignRecipients) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreateEmailCampaignRecipients) UnmarshalBinary(b []byte) error {
	var res CreateEmailCampaignRecipients
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CreateEmailCampaignSender Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example `{"name":"xyz", "email":"example@abc.com"}` , `{"name":"xyz", "id":123}`
// swagger:model CreateEmailCampaignSender
type CreateEmailCampaignSender struct {

	// Sender email
	// Format: email
	Email strfmt.Email `json:"email,omitempty"`

	// Select the sender for the campaign on the basis of sender id. In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email).
	ID int64 `json:"id,omitempty"`

	// Sender Name
	Name string `json:"name,omitempty"`
}

// Validate validates this create email campaign sender
func (m *CreateEmailCampaignSender) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateEmailCampaignSender) validateEmail(formats strfmt.Registry) error {

	if swag.IsZero(m.Email) { // not required
		return nil
	}

	if err := validate.FormatOf("sender"+"."+"email", "body", "email", m.Email.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CreateEmailCampaignSender) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreateEmailCampaignSender) UnmarshalBinary(b []byte) error {
	var res CreateEmailCampaignSender
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
